<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Visualizador 3D com Botões</title>

  <!-- Pré-conexões (acelera rede) -->
  <link rel="preconnect" href="https://aframe.io" crossorigin>
  <link rel="dns-prefetch" href="https://aframe.io">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://zoci6wmxqa.execute-api.us-east-1.amazonaws.com" crossorigin>
  <link rel="dns-prefetch" href="https://zoci6wmxqa.execute-api.us-east-1.amazonaws.com">

  <!-- Cache-buster dinâmico (seguro) -->
  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const tRaw = urlParams.get("t");
    const tSafe = tRaw ? encodeURIComponent(tRaw) : null;
    // Prioriza o parâmetro 't' vindo do QR Code, senão usa um valor fixo
    const cacheBuster = tSafe ? `?t=${tSafe}` : `?v=1.4`;
  </script>

  <!-- CSS externo com cache-buster -->
  <link rel="stylesheet" id="app-css" />
  <script>
    document.getElementById("app-css").href = `../app/app.css${cacheBuster}`;
  </script>

  <!-- Bibliotecas A-Frame e AR.js -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>

  <!-- CONFIGURAÇÃO DAS MÉTRICAS -->
  <script>
    (function () {
      const url = new URL(location.href);

      // URL base da API de MÉTRICAS (HTTP API, stage /metricas)
      const API_METRICAS_BASE = "https://zoci6wmxqa.execute-api.us-east-1.amazonaws.com/metricas";

      // Parâmetros vindos do QR / redirect:
      // app.html?u=ranie.black29%40gmail.com&i=mesa1&v=123&restaurante=ranie-black29-gmail-com&t=...
      const tenant =
        url.searchParams.get("restaurante") ||
        url.searchParams.get("tenant") ||
        url.searchParams.get("r") ||
        url.searchParams.get("u") ||
        null;

      const table =
        url.searchParams.get("mesa") ||
        url.searchParams.get("table") ||
        url.searchParams.get("i") ||
        null;

      const qrId =
        url.searchParams.get("qrId") ||
        url.searchParams.get("qr") ||
        table ||
        null;

      // Evita misturar buffer de métricas entre restaurantes/tenants no mesmo device
      const persistKey = `arcardapio_metrics_v3_${tenant || "unknown"}`;

      window.__AR_METRICA_INIT = {
        endpoint: API_METRICAS_BASE + "/ingest",
        tenant: tenant,
        table: table,
        qrId: qrId,
        env: "prod",
        flushIntervalMs: 10000,
        maxBufferSize: 30,
        persistKey: persistKey,
        sampleRate: 1.0,
        consentMetrics: true,
        heartbeatMs: 30000
      };
    })();
  </script>
</head>

<body>

  <!-- Botão de menu -->
  <button id="menuBtn">Cardápio</button>

  <!-- Botões de categoria -->
  <div id="categoryButtons" style="display: none">
    <button class="category-btn" onclick="selectCategory('bebidas')">Bebidas</button>
    <button class="category-btn" onclick="selectCategory('pizzas')">Pizzas</button>
    <button class="category-btn" onclick="selectCategory('sobremesas')">Sobremesas</button>
    <button class="category-btn" onclick="selectCategory('carnes')">Carnes</button>
    <button class="category-btn" onclick="selectCategory('lanches')">Lanches</button>
    <button class="category-btn" onclick="selectCategory('porcoes')">Porções</button>
    <button class="category-btn" onclick="selectCategory('diversos')">Diversos</button>
  </div>

  <!-- Indicador de carregamento -->
  <div id="loadingIndicator">Carregando...</div>

  <!-- Exibe o preço -->
  <div id="priceDisplay">R$ 0,00</div>

  <!-- Nome do produto -->
  <div
    id="productNameDisplay"
    style="
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #e0e0e0;
      color: #000;
      padding: 6px 16px;
      border-radius: 12px;
      font-size: 1.1em;
      font-weight: 500;
      z-index: 1000;
    "
  ></div>

  <!-- Like / Dislike -->
  <button id="btnDislike" class="btn-like btn-like-left" aria-label="Não gostei">
    <img src="../imagens/negativo.png" alt="Não gostei">
  </button>

  <button id="btnLike" class="btn-like btn-like-right" aria-label="Gostei">
    <img src="../imagens/positivo.png" alt="Gostei">
  </button>

  <!-- Botões para navegar entre os modelos -->
  <button id="prevBtn" class="btn" onclick="changeModel(-1)">
    <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" /></svg>
  </button>
  <button id="nextBtn" class="btn" onclick="changeModel(1)">
    <svg viewBox="0 0 24 24"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6z" /></svg>
  </button>

  <!-- Botão Info (SEM onclick: evita duplo disparo) -->
  <button id="infoBtn" class="btn" style="display: none;">ℹ️ Info</button>

  <!-- Painel de informações -->
  <div
    id="infoPanel"
    style="
      display: none;
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 80vw;
      max-height: 60vh;
      overflow-y: auto;
      background-color: rgba(255, 255, 255, 0.95);
      color: #000;
      padding: 16px 20px;
      border-radius: 16px;
      font-size: 1em;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      text-align: left;
    "
  >
    <button
      id="infoCloseBtn"
      type="button"
      style="
        position: absolute;
        top: 8px;
        right: 12px;
        background: transparent;
        border: none;
        font-size: 1.2em;
        cursor: pointer;
      "
      aria-label="Fechar"
    >✖</button>

    <div id="infoContent">Carregando...</div>
  </div>

  <!-- Cena AR -->
  <a-scene embedded vr-mode-ui="enabled: false" arjs="sourceType: webcam; debugUIEnabled: false;">
    <a-entity
      id="modelContainer"
      rotation="0 180 0"
      position="0 0 0"
      scale="1 1 1"
      gltf-model=""
      gesture-detector
      grabbable
      draggable
      touch-action="none"
      crossorigin="anonymous"
    ></a-entity>

    <!-- NÃO MEXI NA CÂMERA (intocada) -->
    <a-camera position="0 1.5 3"></a-camera>
  </a-scene>

  <!-- Scripts do projeto (carrega metricaapp.js ANTES do app.js para evitar race) -->
  <script>
    document.write(`<script src="../app/models.js${cacheBuster}"><\/script>`);
    document.write(`<script src="../app/metricaapp.js${cacheBuster}"><\/script>`);
    document.write(`<script src="../app/app.js${cacheBuster}"><\/script>`);
    document.write(`<script src="../app/animacaoapp.js${cacheBuster}"><\/script>`);
  </script>

  <!-- PATCH 1: MATAR ANIMAÇÃO DO CHEF/LOGO (sem mexer em câmera / sem quebrar app.js) -->
  <script>
    (function () {
      const el = document.getElementById("modelContainer");
      if (!el) return;

      function getSrc() {
        // A-Frame gltf-model guarda URL no atributo
        const v = el.getAttribute("gltf-model");
        return String(v || "").toLowerCase();
      }

      function isChefOrLogo() {
        const src = getSrc();
        const isChef = src.includes("chef");

        let isLogo = false;
        try {
          isLogo = (typeof currentCategory !== "undefined" && currentCategory === "logo");
        } catch (e) {}

        return isChef || isLogo;
      }

      function killAnimationsIfNeeded() {
        if (!isChefOrLogo()) return;

        // 1) Remove animation-mixer (se algum JS adicionou)
        try {
          if (el.hasAttribute("animation-mixer")) el.removeAttribute("animation-mixer");
        } catch (e) {}

        // 2) Remove animation (se algum JS adicionou animação do A-Frame)
        try {
          if (el.hasAttribute("animation")) el.removeAttribute("animation");
        } catch (e) {}

        // 3) Remove quaisquer animation__* (múltiplas animações)
        try {
          const attrs = el.getAttributeNames ? el.getAttributeNames() : [];
          for (const a of attrs) {
            if (a && a.startsWith("animation__")) el.removeAttribute(a);
          }
        } catch (e) {}
      }

      // Quando trocar o modelo
      el.addEventListener("componentchanged", function (evt) {
        if (!evt || evt.detail?.name !== "gltf-model") return;
        // corta logo após mudança
        killAnimationsIfNeeded();
        // corta de novo após carregar malha (garante)
        setTimeout(killAnimationsIfNeeded, 0);
        setTimeout(killAnimationsIfNeeded, 250);
        setTimeout(killAnimationsIfNeeded, 800);
      });

      // Quando carregar o modelo (caso seu app dispare)
      el.addEventListener("model-loaded", function () {
        killAnimationsIfNeeded();
        setTimeout(killAnimationsIfNeeded, 250);
      });

      // Segurança: após load da página
      window.addEventListener("load", function () {
        killAnimationsIfNeeded();
        setTimeout(killAnimationsIfNeeded, 500);
      });
    })();
  </script>

  <!-- PATCH 2: PREFETCH DO PRÓXIMO GLB (acelera troca de modelo quando URL é cacheável) -->
  <script>
    (function () {
      function extractPossibleUrl(obj) {
        if (!obj) return "";
        return String(
          obj.url ||
          obj.src ||
          obj.model ||
          obj.modelUrl ||
          obj.path ||
          obj.gltf ||
          ""
        );
      }

      function prefetch(url) {
        if (!url) return;
        // evita lixo
        if (!/^https?:\/\//i.test(url) && !url.startsWith("../") && !url.startsWith("./") && !url.startsWith("/")) return;

        // link prefetch (não quebra nada se o browser ignorar)
        const link = document.createElement("link");
        link.rel = "prefetch";
        link.as = "fetch";
        link.href = url;
        link.crossOrigin = "anonymous";
        document.head.appendChild(link);

        // fetch leve (se der, entra no cache)
        try { fetch(url, { mode: "cors", credentials: "omit" }).catch(() => {}); } catch (e) {}
      }

      const original = window.changeModel;
      if (typeof original !== "function") return;

      window.changeModel = function (dir) {
        const next = original(dir) || {};
        const u = extractPossibleUrl(next);
        if (u) prefetch(u);
        return next;
      };
    })();
  </script>

  <!-- INTEGRAÇÃO DE MÉTRICAS + INFO / CATEGORIA -->
  <script>
    // ✅ Info toggle controlado em UM lugar só (sem duplicar click)
    (function () {
      const panel = document.getElementById("infoPanel");
      const btn = document.getElementById("infoBtn");
      const closeBtn = document.getElementById("infoCloseBtn");

      function isVisible() {
        return panel && panel.style.display !== "none" && panel.style.display !== "";
      }

      window.toggleInfo = function () {
        if (!panel) return;
        if (isVisible()) {
          panel.style.display = "none";
          panel.classList.remove("open", "show");
        } else {
          panel.style.display = "block";
          panel.classList.add("open");
        }
      };

      // Listener único no botão
      if (btn) btn.addEventListener("click", window.toggleInfo, { passive: true });

      // Fechar também passa pelo toggle (mantém métricas consistentes)
      if (closeBtn) closeBtn.addEventListener("click", function () {
        if (isVisible()) window.toggleInfo();
      }, { passive: true });
    })();

    // ✅ Depois que tudo carregar, inicializa autoBind
    window.addEventListener("load", function () {
      if (window.MetricaApp) {
        try { window.MetricaApp.autoBind(); } catch (e) { console.error(e); }
      }
    });

    // ✅ Integração com mudança de modelo (tempo de visualização por item)
    (function () {
      const originalChangeModel = window.changeModel;
      window.changeModel = function (dir) {
        if (typeof originalChangeModel === "function") {
          const next = originalChangeModel(dir) || {};
          if (window.MetricaApp && (next.id || next.name)) {
            try {
              window.MetricaApp.setCurrentItem({
                id: next.id ?? null,
                name:
                  next.name ??
                  (document.getElementById("productNameDisplay")?.textContent?.trim() || null),
                category: next.category ?? null,
                price: next.price ?? null
              });
            } catch (e) {
              console.error(e);
            }
          }
          return next;
        }
      };
    })();

    // ✅ Integração com seleção de categoria
    (function () {
      const originalSelectCategory = window.selectCategory;
      window.selectCategory = function (cat) {
        if (typeof originalSelectCategory === "function") {
          originalSelectCategory(cat);
        }
        if (window.MetricaApp) {
          try { window.MetricaApp.trackEvent("category_select", { category: cat }); }
          catch (e) { console.error(e); }
        }
      };
    })();

    // OBS: like/dislike continuam sendo controlados pelo app.js
  </script>
</body>
</html>
